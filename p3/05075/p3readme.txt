        Program 3                               CS480 Fall 2021

Deadlines:      TWO deadlines will be listed in ~cs480/calendar, since you can
                get 20% extra credit if you finish about a week early.

--> Specifications <--

This assignment deals with semaphores, concurrent tasks, and shared variables.
Imagine that you are running a widget factory. Your robots build widgets
in the factory. When a robot completes a new widget, it carries the
widget to the warehouse, and neatly stores it there. The (foolish) way
we model this activity is with multiple processes that each execute a program,
p3robot. Every time a robot places its new widget in the warehouse, that
robot prints out its own pid (always in six columns, no matter how few
digits make up the pid). The interesting part is that we require the
widgets to be neatly placed in a triangular warehouse. That is, the printout
of all robot reports will have just one entry on the last line, two on the
next-to-last line, 3 above that one, and so on. Each robot is to place 'quota'
widgets ('quota' is an argument on the command line) and then quit. Thus, if
quota is 3, then four robots that happen to have pid's 11047, 4511, 7300, and
2239, should produce a layout of the following shape in the warehouse:
  2239  4511N
 11047  7300  2239  7300N
  2239  7300  4511N
 11047 11047N
  4511F
where the " F\n" terminator is put out by the last robot to place a
widget. (Except for this 'F', the robots mark the end of rows with "N\n",
that is, the letter 'N' followed by a newline character.) Observe how the N's
are always at the ends of the rows, and that each row (except perhaps that first
row) contains one less PID than the previous row.  Note that while the order of
the pids [and the pid numbers themselves] will vary on each run, but the shape
in the warehouse should always be triangular for any particular quota and
number of robots (though the first line might well be incomplete).

Before the robots can do much of anything, they need to do 'some math' to
determine the layout.  For example, calculating the total number of widgets
(= nrRobots*quota) will allow the last robot to figure out that it should
'turn off the lights and close up shop' (i.e., print the final "F\n").
A trickier calculation is needed to figure out the number of rows that will
be needed (and in particular whether the first row should be shorter than
a triangle would indicate).  For the above 4*3=12 widgets, 4 rows fill up
10 slots, so the top row gets only 12-10=2 widgets.  If we had had 5 robots
(yielding 15 widgets), the top row would be completely filled.  (If you
determine your calculations need something like sqrt(), check the man page
to find out what you need to #include !)  While it is marginally acceptable
to program in a huge table of perhaps 100 values to determine the proper
top-row length in each case, this will not be regarded as full-credit solution.
Accurate formulas are the only way to handle the potentially infinite number
of scenarios, and getting the formulas right will likely be worth some extra
credit.  (How much extra depends on how many students discover and implement
the correct formulas.)

Since this precise placement format is the major requirement of the assignment, please talk to me if it is not clear what constitutes the correct layout.

The robots are to run as concurrent processes, coordinating their activity
in order to know when to start a new line (and print "F\n").

The robots are started by the p3 command:
  p3 nrRobots [ seed [ quota ]]
Where
    * nrRobots is a positive integer <= MAXROBOTS,
    * seed is an integer starter for the random number generator,
    * quota is a nonnegative integer specifying the number of widgets
      that each robot should make.

The sample above might have been generated by:
  p3 4 999 3

Defaults and referenced constants may be found in ~cs480/three/p3.h
These imply that
  p3 5
would start 5 widget-building robots as concurrently-running processes,
with default values for the initial seed and the quota.

The robots learn how many robots are working from their argv parameters. Note
that p3 gives the same parameters to each robot. (In the real world,
we'd probably want the robots to figure this all out for themselves --
and even be able to adapt if some of their coworkers broke down. You might
think about methods of achieving such a goal; however, don't implement
such automation in what you hand in.)

Your solution should allow retests without manual cleanup. No garbage should
be left in /tmp.  For example, after the example illustrated above completes,
it ought to be possible to do another test, such as
  p3 2 111
without typing in commands for removing or initializing files. 

IMPORTANT requirement: Obviously, your robots must coordinate with each other
to get the right picture in the warehouse. However, this coordination should
not interfere with robots back in the factory making new widgets. And a robot
building a widget in the factory should not be blocking some other robot that
is trying to place a widget in the warehouse. (In other words, your solution
should not sacrifice concurrency except as absolutely necessary.) An almost
sure sign that you have violated this requirement would be if the widgets
always turned up in the warehouse in blocks: for example, all the widgets
from one robot, then all the widgets from another, and so on. This would be
an indication of a flawed solution.

In order to follow the factory rules, all robots make use of the 
initStudentStuff() and placeWidget() functions. Most of your work will
involve writing these two routines in p3helper.c.
(That is, all the ugly work of setting up the simulation, generating robots
and defining their properties has already been done for you.  You only have to
see that each robot 'follows the rules' by ensuring the appropriate
coordination in the placeWidget() function.)

In addition to the concrete "rules" of the factory, there are
"desirable" properties of a solution. These are also gradable issues.
For example, process blocking is more desirable than busy waiting.
Your solution should support as much concurrency as possible while
still enforcing the specifications of the problem.

You should use POSIX semaphores to solve this problem. However, the only
semaphore functions you are allowed to use (but you may not need them all) are:
sem_open
sem_init
sem_wait
sem_post
sem_close
sem_unlink

edoras has man pages for these system calls, and you may also find useful info
on the web, such as:
http://www.kernel.org/doc/man-pages/online/pages/man3/sem_open.3.html
Make sure you pay attention to POSIX pages ONLY, or you might be misled,
since different types of semaphores can have different behavior and syntax.

You are allowed to [create and] use a common file [in your current working
directory] to store information that you want all the robots to share
(AS LONG AS you 'clean up' afterward and unlink() the file). ~cs480/semex.c
shows some of the syntax needed.  However, the parent in semex.c opens the file
and creates the semaphores prior to forking the children, so those child
processes automatically knew about these objects.  Due to the structure of
the p3 files, your robots have to coordinate the creation of these items by
themselves rather than having these items handed to them by the parent process.
A common mistake is to have ALL the robots (re)set the semaphore(s); if
you are using a semaphore for mutual exclusion, having a second robot set it to
1 after another robot has driven it down to 0 can violate mutual exclusion.
One way to coordinate is to pay attention to what sem_open() returns and use
different parameters in different situations.  As in semex.c, your semaphore
name must start with '/' or you will always get a return value of SEM_FAILED.

The robots do not share memory space, so if you define a variable in
p3helper.c, that variable will be local to the process; each robot will have
such a variable, and other robots can only 'see' the contents of the variable
it created; it can't access the variables of other robots.  ~cs480/semex.c
uses a common file to pass information between the child processes to get
around this limitation.  Note that even if you successfully arrange for
only one robot to initialize the common file, it would still be very BAD if
another robot could start reading/writing this file in placeWidget() before
the 'first' robot had finished writing the initial value in initStudentStuff().

Race conditions typically show up only rarely, so you should test your
program thoroughly.  The autograder will run a few tests, but after collection,
I will download, compile, and run your program an INSANE number of times to
try to tickle the bugs.  You may wish to TEMPORARILY add some sleep() calls to
p3helper.c to try to tickle the bugs, but there should be NO sleep() calls
in your final submission (sometimes sleep() can mask errors rather than
expose them).  I also recommend redirecting your p3 output to a file and
then examining the contents of the file, because block-buffered output is
more likely to expose errors than line-buffered output, e.g.,
p3 3 3 3 > outfile
cat outfile
Make sure you understand why printeger() is using fflush()!

--------------

--> Implementation <--

The p3 project should contain only the following files, all in the
subdirectory ~/Three.  (You should see me if you feel you need more files.)
Don't permit any of your files to be public.

p3 --   the executable program.  This can be compiled and run before you write
        any code, but it will fail miserably.  p3 accepts the arguments
        described above, including a random seed so that you can test your
        protocols under many different environments.

gradernotes -- The file called ~/Three/gradernotes is intended to be read by a
        human grader. It should contain any notes that you want the grader to
        read.  ~/Three/gradernotes *must* contain certain things, IN THIS ORDER:
 1)     A statement certifying that: "I wrote the p3helper.c code myself."
 2)     A statement certifying that:
        "I believe everything works perfectly under all conditions", or
        else you must point out (and try to explain) places where your p3
        does not meet the specs.
 3)     An explanation of how you achieved successful coordination.
 4)     An indication of whether you used formulas or created a table of values.
 5)     (optional) Any additional information you wish to include.

        If the failure is due to an underlying weakness of the specs,
        explain how the problem might be fixed.  If your program only works
        under very special conditions, you must support your contention
        that it works at all by including script session(s) at the end of
        ~/Three/gradernotes in which you test your p3 on examples that work.

NOTE: there is an executable file ~cs480/Three/createlinks which will create
the ~/Three directory and all the links described below.  EITHER run that file,
OR mkdir ~/Three and run all the 'ln' commands listed below 'by hand'.

makefile -- the makefile for this project.  This should simply be a symbolic
        link to the file  ~cs480/Three/makefile .
        Establish such a link (once and for all) with the command:
            ln -s ~cs480/Three/makefile ~/Three/makefile
        Note that your final suite of files must be capable of producing an
        executable p3 by typing nothing more than
            make
        when the current directory is ~/Three.
        You should study this makefile carefully since it implies various
        things about how your project must be put together.

CHK.h -- This should simply be a symbolic link to the file ~cs480/Three/CHK.h .
        Establish such a link (once and for all) with the command:
            ln -s ~cs480/Three/CHK.h ~/Three/CHK.h
        (Using the CHK.h macro in your code is allowed but not required.)

p3.h -- header information for your program. This should simply be a
        symbolic link to the file ~cs480/Three/p3.h . Establish such a link
        (once and for all) with the command:
            ln -s ~cs480/Three/p3.h  ~/Three/p3.h
        You should study this file, but keep in mind that (as with many
        real programming situations) the definitions given there may be
        changed as time goes on. Your implementation should be able to
        accommodate such changes with a minimum of programmer inconvenience.

p3main.c -- The driver program for the database. This should simply be a
        symbolic link to the file  ~cs480/Three/p3main.c . Establish such a link
        (once and for all) with the command:
            ln -s ~cs480/Three/p3main.c  ~/Three/p3main.c
        You don't change this file, but understanding what it does is
        important.  Note that p3main.c also contains a documented example of
        the use of POSIX-named semaphores for Linux (and some references
        about the topic).

p3robot.c -- The code for the executable program that is run by multiple
        processes to place the widgets in the properly-formatted way.  This
        should simply be a symbolic link to the file  ~cs480/Three/p3robot.c .
        Establish such a link (once and for all) with the command:
            ln -s ~cs480/Three/p3robot.c  ~/Three/p3robot.c
        You don't change this file, but understanding what it does is important,
        since there are function calls here to routines that you will write in
        p3helper.c. Note that p3robot.c also contains an example of the use of
        POSIX named semaphores for Linux. (This example works together with
        the example in p3main to coordinate the driver program's termination.)

p3helper.c -- This is the only file you can change. Here you will provide
        some data definitions and complete the code for several routines.
        (Stubs for the visible functions are already present in
        ~cs480/Three/p3helper.c . A limited amount of documentation is already
        present in p3.h .)  Once completed, the routines in p3helper should
        allow p3main to govern access to the database according to the
        Rules described in this assignment.)
            cp ~cs480/Three/p3helper.c  ~/Three/p3helper.c
        ...and then add your own code.

RCS/ -- an optional directory for those who wish to use the Revision
        Control System

GradeEarly -- The file called ~/Three/GradeEarly (note the odd capitalization)
is intended to signal that you have completed the project early, and
wish to take advantage of the extra credit reward.  The contents of the file
are immaterial; the autograder will only test for the existence of this file;
if the file has been created by the 120% deadline, your project will be
picked up for grading at that time (so no further changes to your code or
documentation will be possible).  If you don't have a correct solution,
DON'T try for the extra credit (because you won't get it)!